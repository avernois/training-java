<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Java - advanced</title>
  <meta name="description" content="A framework for easily reating beautiful presentations using HTML">
  <meta name="author" content="Hakim El Hattab">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/black.css" id="theme">

  <!-- Code syntax highlighting -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <!-- Printing and PDF exports -->
  <script>
  var link = document.createElement( 'link' );
  link.rel = 'stylesheet';
  link.type = 'text/css';
  link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
  document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>

  <!--[if lt IE 9]>
  <script src="lib/js/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
    <div class="reveal">
        <div class="slides">      
                <section>
                    <h1>Java</h1>
                    <h3>advanced</h3>
                    <p>
                        <small><a href="http://blog.crafting-labs.fr">Antoine Vernois</a> / <a href="http://twitter.com/avernois">@avernois</a></small>

                    </p>
                </section>

                <section>
                    <section>
                        <h2>Antoine Vernois</h2>
                        <p>Agile Software Craftsman</p>
                        <p class="fragment">Software Anarchist</p>
                        <p>blog : <a href="https://blog.crafting-labs.fr">https://blog.crafting-labs.fr</a></p>
                        <p>twitter : <a href="http://twitter.com/avernois">@avernois</a></p>
                    </section>

                    <section>
                        <h2>et vous ?</h2>
                        <h3>post-it</h3>
                        <p>Vous attendez quoi de cette formation ?</p>
                        <br>
                        <div class="fragment">
                            <h3>tour de table</h3>

                            <ul class="fragment">
                                <li>qui êtes vous ?</li>
                                <li>qu'est ce que vous faites ?</li>
                                <li>qu'est ce que vous aimez ?</li>
                                <li>qu'est ce que vous aimez moins ?</li>
                                <li>votre expérience avec les tests et le tdd ?</li>
                            </ul>
                        </div>
                    </section>

                    <section>
                        <h3>détails pratiques</h3>
                        <ul>
                            <li>horaires</li>
                            <li>repas</li>
                            <li>pauses</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Maven</h1>
                    </section>  
                    <section>
                        <h2>maven, un outil</h2>
                        <ul>
                            <li>de build</li>
                            <li>de gestion de dépendance</li>
                            <li>de documentation</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Simple POM</h2>
                        <pre><code class="xml" data-trim contenteditable>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
        http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>fr.craftinglabs.training</groupId>
  <artifactId>my-app</artifactId>
  <packaging>jar</packaging>
  <version>1.0-SNAPSHOT</version>
  <name>My awesome project</name>
</project>
                        </code></pre>
                    </section>
                    <section>
                        <h2>Sources structure</h2>
                        <pre><code class="xml" data-trim contenteditable>
my-app
+- pom.xml
  +- src
    +- main
    | +- java
    | +- resources
    +- test
      +- java
      +- resources

                        </code></pre>
                    </section>
                    <section><h2>ajouter des dépendances</h2>
                        <pre><code class="xml" contenteditable>
<project>
    <!-- snip -->
    <dependencies>
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.11</version>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
                        </code></pre>
                        <p>3 types de scope</p>
                        <ul>
                            <li>compile</li>
                            <li>test</li>
                            <li>runtime</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Trouver les dépendances</h2>
                        <ul>
                            <li><a href="http://search.maven.org/">http://search.maven.org/</a></li>
                            <li><a href="http://mvnrepository.com/">http://mvnrepository.com/</a></li>
                            <li>google marche bien aussi :)</li>
                        </ul>
                        <p>Note: avoir son propre repository manager en interne peut être une bonne idée :)</p>
                    </section>

                    <section>
                        <h2>Cycle de vie</h2>
                        les phases du cycle de vie du build les plus courantes :

                        <ul>
                            <li>process-resources</li>
                            <li>compile</li>
                            <li>test</li>
                            <li>package</li>
                            <li>install</li>
                            <li>deploy</li>
                        </ul>
                        <p>Il y en a bien d'autres : <a href="https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html">Doc Maven</a></p>
                    </section>
                    <section>
                        <h2>filtrer les resources</h2>
                        <p>Remplacer un variable (ex: <code>${nom.variable}</code>) par sa valeur définie dans le pom.
                        <pre><code class="xml" contenteditable>
<project>
    <!-- snip -->
  <build>
    <resources>
      <resource>
        <directory>src/main/resources</directory>
        <filtering>true</filtering>
      </resource>
    </resources>
  </build>
</project>
                        </code></pre>
                    </section>
                    <section><h2>définir ses properties</h2>
                        <p><code>${my.properties}</code></p>
                        <pre><code class="xml" contenteditable>
<project>
    <properties>
        <my.properties>hello</my.properties>
    </properties>
</project>
                        </code></pre>
                    </section>

                    <section>
                        <h2>multi modules</h2>
                        <pre><code class="xml" contenteditable>
 <project>
  <modelVersion>4.0.0</modelVersion>
 
  <groupId>fr.craftinglabs.training</groupId>
  <artifactId>app</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>pom</packaging>
 
  <modules>
    <module>my-app</module>
    <module>my-webapp</module>
  </modules>
</project>
                        </code></pre>
                    </section>  
                    <section>
                        <h2>structure</h2>
                        <pre><code class="xml" contenteditable>
+- pom.xml // le pom parent
+- my-app
| +- pom.xml
| +- src
|   +- main
|     +- java
+- my-webapp
| +- pom.xml
| +- src
|   +- main
|     +- webapp
                        </code></pre>

                    </section>

                    <section>
                        <h2>super pom</h2>
                        <p>Dans les poms des modules, on rajoute un lien vers le pom parent</p>

                        <pre><code class="xml" contenteditable>
  <parent>
    <groupId>fr.craftinglabs.training</groupId>
    <artifactId>app</artifactId>
    <version>1.0-SNAPSHOT</version>
  </parent>
                        </code></pre>
                    </section>
                </section>

               <section>
                    <section>
                        <h1>Collections</h1>
                    </section>
                    <section><h2>Overview</h2>
                        sortir le schéma qui va bien :)
                    </section>

                    <section>
                        <h2>Iterable</h2>
                        <p><code>Iterable</code> est l'interface des Collection</p>
                        <pre><code class="java" data-trim>
public interface Iterable&lt;T&gt; {
    Iterator&lt;T&gt; iterator();
}

public interface Iterator&lt;T&gt; {
    boolean hasNext();
    T next();
    void remove(); // à implémenter uniquement si on le supporte
}         
                        </code></pre>


                    </section>

                    <section><h2>iterable et for-loop</h2>
                        <pre><code class="java" data-trim>
Iterable&lt;AType&gt; iterable = .. ;
for(AType item : iterable) {
    doThings();
}
                       </code></pre>
                    </section>

                    <section>
                        <h2>Collection</h2>
                        <h3>ajout, retrait</h3>
                        <pre><code class="java" data-trim contenteditable>
String anElement = "an element";
Collection collection = new HashSet();

boolean collectionChanged = collection.add(anElement); 
boolean elementRemoved = collection.remove(anElement);

collection.addAll(aSet); // aSet is a Set :)
collection.removeAll(aSet);
collection.retainAll(aSet); // ne garde dans collection que les éléments présent dans aSet.
                        </code></pre>
                    </section>

                    <section>   
                        <h2>List</h2>
                        <ul>
                            <li>Collection ordonnée</li>
                            <li>un élément peut être présent plusieurs fois</li>
                            <li>implem : ArrayList, LinkedList, Vector, Stack</li>
                        </ul>

                        <h3>accès</h3>
                        <pre><code class="java" data-trim contenteditable>
List&lt;String&gt; listA = new ArrayList&lt;&gt;();
listA.add("element 1");
listA.add("element 2");

listA.add(0, "element 0"); // qu'est ce qui se passe ?

listA.remove(0);
listA.remove("element 1");

                        </code></pre>
                    </section>

                    <section>   
                        <h3>Set</h3>
                        <ul>
                            <li>un élement ne peut être présent qu'une fois</li>
                            <li>implem: HashSet, TreeSet, EnumSet, LinkedHashSet</li>
                        </ul>
                        <h3>accès</h3>


                        <pre><code class="java" data-trim contenteditable>
Set&lt;String&gt; setA = new HashSet&lt;&gt;();

setA.add("element 0");
setA.add("element 1");
setA.add("element 2");

setA.remove("element 0");      
                        </code></pre>
                    </section>

                    <section>
                        <h2>SortedSet</h2>
                        <p>Un type de Set trié automatiquement.</p>
                        <pre><code class="java" data-trim contenteditable>
SortedSet&lt;String&gt; setA = new TreeSet&lt;&gt;();

Comparator&lt;String&gt; comparator = new MyComparator&lt;&gt;();
SortedSet&lt;String&gt; setB = new TreeSet&lt;String&gt;(comparator);                        
                        </code></pre>
                    </section>

                    <section>
                        <h2>NavigableSet</h2>
                        <pre><code class="java" data-trim contenteditable>
NavigableSet&lt;String&gt original = new TreeSet&lt;&gt;();
original.add("1");
original.add("2");
original.add("3");
original.add("4");

NavigableSet&lt;String&gt; reverse = original.descendingSet();

NavigableSet&lt;String&gt; headset = original.headSet("3"); // contient 1 et 2
NavigableSet&lt;String&gt; subset  = original.subSet("1", "3"); // contient 1, et 2
                        </code></pre>
                    </section>


                    <section>
                        <h2>Queue</h2>
                        <p>Comme une liste, sauf que l'objectif est d'ajouter les élements à la fin, et de les rétirer au début.</p>
                        <h3>accès</h3>
                        <pre><code class="java" data-trim contenteditable>
Queue&lt;String &gt; queue = new LinkedList&lt;&gt;();

queue.add("element 0");
queue.add("element 1");
queue.add("element 2");

queue.remove(); // retire et retourne "element 0"
queue.peek(); // retourne "element 0" sans le retirer
                        </code></pre>
                    

                    </section>

                    <section>
                        <h2>DeQue</h2>
                        <p>Comme une Queue, sauf qu'on peut y accéder des deux côté</p>
                        <h3>accès</h3>
                        <pre><code class="java" data-trim contenteditable>
DeQue&lt;String &gt; dequeue = new LinkedList&lt;&gt;();

deque.add("element 1"); // ajout à la fin
deque.addFirst("element 0"); // ajout au début
deque.addLast("element 2"); // ajout à la fin

deque.remove(); // retire et retourne "element 0"
deque.peek(); // retourne "element 0" sans le retirer
                        </code></pre>
                    </section>

                    <section>
                        <h2>Stack</h2>
                        <p>Une stack est une implémentation de List, dont l'objectif est d'être une LIFO.</p>
                        <pre><code class="java" data-trim contenteditable>
Stack&lt;String&gt; stack = new Stack&lt;&gt;();

stack.push("1");
stack.push("2");
stack.push("3");

String top = stack.peek(); // retourne "3" sans le retirer

int index = stack.search("3"); // retourne 1 ("3" est en tête)
                               // yep, l'index des stack commence à 1 :)

stack.pop(); //retourne "3" et le retire
stack.pop(); //retourne "2" ...
stack.pop(); //retourne "1"
                        </code></pre>
                    </section>

                    <section>
                        <h2>Map</h2>
                        Permet de stocker des ensembles clés-valeurs.
                        Tous les élements sont itérables
                        <pre><code class="java" data-trim>
Map&lt;Integer, String&gt> map = new HashMap&lt;&gt;();
map.put(1, "1");
String value = map.get(1);

Set&lt;Map.Entry&lt;K, V&gt;&gt; entries = map.entrySet();
Set&lt; keys = map.keySet();
Collection&lt;V&gt; values = map.values();
                        </code></pre>
                    </section>

                    <section>
                        <h2>SortedMap</h2>
                        <p>Comme les SortedSet, mais avec des Map :)</p>

                        <h2>NavigableMap</h2>
                        <p>idem</p>
                    </section>

                    <section>
                        <h2>Equals et Hashcode</h2>
                        <p>Pour que equals() et contains() fonctionne comme on peut s'y attendre sur les listes, il est indispensable de que equals et hashcode des objets contenus soit correctement défini !</p>
                        <br>
                        <h3>WARNING !</h3>
                        <p>equals et hashcode doivent toujours être surchargé ensemble !</p>
                        <h3>L'unique règle du hashcode</h3>
                        Si obj1.equals(obj2) alors obj1 et obj2 doivent avoir le même hashcode.
                    </section>

                    <section>
                        <h2>Trier les listes</h2>
                        <p>Collections.sort(List) ou List.sort depuis 1.8</p>
                        <pre><code class="java" data-trim>
List&lt;String&gt; list = Arrays.asList("1", "3", "2");
Collections.sort(list); // tri selon l'ordre naturel

Comparator&lt;String&gt; comparator = new MyStringComparator();

Collections.sort(list, comparator);  
list.sort(comparator); // 1.8
                        </code></pre>                      
                    </section>
                    <section>
                        <h2>Comparator</h2>
<pre><code class="java" data-trim>
public interface Comparator&lt;T&gt; {
    int compare(T object1, T object2);
}

public class MyStringComparator implements Comparator&lt;String&gt; {

    public int compare(String s1, String s2){
        int compare;
       // si s1 > s2, compare > 0
       // si s1 == s2, compare = 0
       // si s1 < s2, compare < 0
       return compare;
    }
}
</code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Generics et collections</h1>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Lambda</h1>
                    </section>

                    <section>
                        <h2>en java 7</h2>
                        <pre><code class="java" data-trim contenteditable>
public interface StateChangeListener {
    public void onStateChange(State oldState, State newState);
}
--
public class StateOwner {
    public void addStateListener(StateChangeListener listener) { ... }
}
--
StateOwner stateOwner = new StateOwner();

stateOwner.addStateListener(new StateChangeListener() {
    public void onStateChange(State oldState, State newState) {
        System.out.println("State changed")
    }
});                        
                        </code></pre>
                    </section>

                    <section>
                        <h2>en java 8</h2>
                        <pre><code class="java" data-trim contenteditable>
stateOwner.addStateListener(new StateChangeListener() {
    public void onStateChange(State oldState, State newState) {
        System.out.println("State changed")
    }
});
                        </code></pre>
                        devient                     
                        <pre><code class="java" data-trim contenteditable>
stateOwner.addStateListener(
    (oldState, newState) -> System.out.println("State changed"));
                        </code></pre>
                    </section>


                    <section>
                        <h2>Lambda et collections</h2>
                        <p>On passe par les streams pour relier les deux.</p>
                        <pre><code class="java" data-trim contenteditable>
List&lt;String&gt; items = new ArrayList&lt;String&gt;();

items.add("un");
items.add("deux");
items.add("trois");

Stream&lt;String&gt; stream = items.stream();
                        </code></pre>
                    <p>Ensuite la manipulation se passe en deux phases :</p>
                    <ul>
                        <li>la config</li>
                        <li>la processing</li>
                    </ul>

                    </section>

                    <section>
                        <h2>config</h2>
                        <h3>filter</h3>
                        <pre><code class="java" data-trim contenteditable>
stream.filter(item -&gt; item.startWith("u"));
                        </code></pre>
                        <h3>map</h3>
                        <pre><code class="java" data-trim contenteditable>
stream.map(item -&gt; item.toUpperCase());
                        </code></pre>
                    </section>

                    <section>
                        <h2>procession</h2>
                        <h3>collect</h3>
                        <pre><code class="java" data-trim contenteditable>
List&lt;String&gt; strings = stream.map(item -&gt; item.toUpperCase())
                                   .collect(Collectors.toList());
                        </code></pre>
                        <h3>reduce</h3>
                        <pre><code class="java" data-trim contenteditable>
String reduced = items.stream()
        .reduce((acc, item) -> acc + " " + item)
        .orElse("");
                        </code></pre>
                        <h3>min maw</h3>
                        <pre><code class="java" data-trim contenteditable>
String shortest = items.stream()
        .min(Comparator.comparing(item -> item.length()))
        .orElse("");
                        </code></pre>

                    </section>
                </section>



                <section>
                    <section>
                        <h1>Debugger</h1>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Logging</h1>
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Réflexion</h1>
                        <h1> &amp; introspection</h1>
                    </section>
                    <section>
                        <h2>Example</h2>
                        <pre><code class="java" data-trim contenteditable>
Class helloClass = HelloWorld.class;                            
Method[] methods = helloClass.getMethods();
for(Method method: methods) {
    System.out.println(methods.getName());
}
                        </code></pre>

                    </section>
                    <section>
                        <h2>Class</h2>
                        <pre><code class="java" data-trim contenteditable>
Class helloClass = HelloWorld.class;
String fullClassName = helloClass.getName(); // fully qualified

// sans le package                        
Sring simpleClassName = helloClass.getSimpleName(); 
                        </code></pre>
                        <h3>modifiers</h3>
                        <pre><code class="java" data-trim contenteditable>
int modifiers = helloClass.getModifiers();

// les modifiers sont encodés dans un int.
// il faut passer par Modifier pour le décoder
Modifier.isPublic(modifiers);
Modifier.isFinal(modifiers);
...                            
                        </code></pre>
                    </section>

                    <section>
                        <h2>Constructeur</h2>
                        <pre><code class="java" data-trim contenteditable>
Constructor[] constructors = helloClass.getConstructors();

//le constructeur avec une String en paramêtre
Constructor&lt;HelloWorld&gt; constructor = helloClass.getConstructors(new Class[]{String.class});

                        </code></pre>
                        <h3>instanciation</h3>
                        <pre><code class="java" data-trim contenteditable>

HelloWorld hello = constructor.newInstance("myArgs");                         
                        </pre></code>
                    </section>

                    <section>
                        <h2>fields</h2>
                        <pre><code class="java" data-trim contenteditable>
Field[] fields = helloClass.getFields();

Field field = helloClass.getField("myField");
Class fieldType = field.getType();


HelloWorld hello = new HelloWorld();
field.get(hello);
field.set(hello, value);

//pour un champ static
someStaticField.set(null, value);
                        </code></pre>
                    </section>
                    <section>
                        <h2>Methods</h2>
                        <pre><code class="java" data-trim contenteditable>
Method[] methods = helloClass.getMethods();

// si HelloWorld a une methode myMethodName(String param);
Method method = helloClass.getMethod("myMethodName", String.class);

Class returnType = method.getReturnType();
Class[] paramTypes = method.getParameterTypes();


method.invoke(hello, "first param");
                        </code></pre>
                    </section>
                    <section>
                        <h2>Méthodes et champs privés</h2>
                        <p>Les méthodes getFields, getMethods précédentes ne retourne que les méthodes publiques. Pour toutes les avoir, il faut passer par: </p>
                        <pre><code class="java" data-trim contenteditable>
helloClass.getDeclaredMethods();
helloClass.getDeclaredMethod("myPrivateMethodName", String.class);

helloClass.getDeclaredFields();
helloClass.getDeclaredField("myPrivateField");
                        </code></pre>
                        Pour invoquer une méthode privée ou changer une valeur d'un champ privé, il faut d'abord le rendre visible
                        <pre><code class="java" data-trim contenteditable>
aPrivateField.setAccessible(true);
aPrivateMethod.setAccessible(true);
                        </code></pre>
                    </section>
                    <section>
                        <h2>les arrays</h2>
                        Il faut passer par la classe <code>Array</code>
                        <pre><code class="java" data-trim contenteditable>
int[] array = (int[]) Array.newInstance(int.class, 5);

Array.set(array, 0, 42);
Array.get(array, 0):

String[] strings = new String[3];
Class stringArrayClass = strings.getClass();
Class stringArrayComponentType = stringArrayClass.getComponentType(); 
                        </code></pre>
                    </section>
                    <section>
                        <h2>ClassLoader</h2>
                        <p>Toutes les classes sont chargées par une instance de ClassLoader (pas forcemment la même pour toutes les classes).</p>
                        <p>Les différent ClassLoader d'une application sont organisé de façon hierarchique.</p>
                        <ol>
                            <li>le CL regarde si la classe est déjà chargée</li>
                            <li>si non, il demande à son parent de le faire</li>
                            <li>si le parent ne trouve pas la classe, il le fait lui même.</li>
                        </ol>
                    </section>
                    <section>
                        <h2>Dynamic ClassLoading</h2>
                        <pre><code class="java" data-trim contenteditable>

public class MyClass {

  public static void main(String[] args) throws ClassNotFoundException {

    ClassLoader classLoader = MyClass.class.getClassLoader();

    Class clazz = classLoader.loadClass("fr.craftinglabs.training.java.ToLoad");
}
                        </code></pre>                        
                    </section>
                    <section>
                        <h2>Dynamic reload</h2>
                        <p>Vu que par défaut, un ClassLoader ne recharge pas une classe qu'il a déjà chargée, pour faire du reloading, il faut créer son propre ClassLoader</p>
                        <p>Sauf que. Une même classe, chargée par deux ClassLoader différents est vu comme deux classes distinctes (et non compatible).</p>
                    </section>  
                    <section>
                        <h2>Proxy</h2>
                        <p>La réflexion permet de créer dynamiquement des implmentations d'interface.</p>

                        <pre><code class="java" data-trim contenteditable>
//le truc vers qui seront transférer tous les appels
InvocationHandler handler = new MyInvocationHandler();


MyInterface proxy = (MyInterface) Proxy.newProxyInstance(
                            MyInterface.class.getClassLoader(),
                            new Class[] { MyInterface.class }, // la liste des interfaces à implémenter
                            handler);
                        </code></pre>
                    </section>

                    <section>
                        <h2>Invocation handler</h2>
                        <pre><code class="java" data-trim contenteditable>                      
public interface InvocationHandler{
  Object invoke(Object proxy, Method method, Object[] args)
         throws Throwable;
}
                        </code></pre>
                    </section>
                </section>
 
<section>
    <section>
        <h1>Expérience</h1>
    </section>
    <section>

        <h2>expérience 1</h2>
        <p>Vous voyez quatre carte</p>

<pre>
                     ___    ___    ___    ___
                    |   |  |   |  |   |  |   |
                    | D |  | 7 |  | 5 |  | K |
                    |___|  |___|  |___|  |___|
</pre>
        <p>Sur chaque carte, il y a un chiffre d'un côté, une lettre de l'autre</p>.
        <br>
        <p>Quelle(s) carte(s) faut-il retourner pour savoir si la règle suivante est vérifiée :<br>
            S'il y a un D d'un côté, alors il y a 5 de l'autre ?</p>
    </section>
    <section>
        <h2>expérience 2</h2>
        <p>Quatres personnes sont dans un bar. Vous savez :</p>
        <ol>
            <li>La personne 1 boit une boisson alcoolisée.</li>
            <li>La personne 2 à moins de 18 ans.</li>
            <li>La personne 3 à plus de 18 ans.</li>
            <li>La personne 4 boit une boisson non-alcoolisée?</li>
        </ol>

        <br>
        <p>Quelle(s) personne(s) faut-il intéroger pour savoir si la règle suivante est vérifiée :<br>
            Si un personne boit de l'alcool, elle doit avoir plus de 18 ans ?</p>
    </section>
</section>


                <section>
                    <section>
                        <h1>Annotations</h1>
                    </section>
                    
                    <section>
                        <h2>Format - utilisation</h2>
                        devant l'élement auquel il s'applique
                        <pre><code data-trim>
@Author(name="Antoine", date="2016/04/04")
public class MyAnnotatedClass {

    @MyAnnotation
    public void myAnnotatedMethod(@MyParamAnnotation String param) {
    ...
    }
}
                    </code></pre>
                    </section>

                    <section><h2>Format - écriture</h2>
                        <pre><code data-trim>
public @interface Author {
    String name() default "Antoine";
    String date();
}
</pre></code>
                    </section>
                    <section><h2>Format - écriture</h2>
                        Les annotations sont définies à l'aide d'annotations:
                        <pre><code data-trim>
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.CLASS})
@Inherited
public @interface Author {
    String name() default "Antoine";
    String date();
}
</pre></code>
                    </section>
                    <section><h2>@Retention</h2>
                        La durée de vie de l'annotation
                        <ul>
                            <li>RUNTIME : disponible via reflexion au runtime</li>
                            <li>CLASS (défaut): stockée dans la classe, mais innaccessible au runtime</li>
                            <li>SOURCE : disparait à la compile (pour l'analyse statique)</li>
                        </ul>
                    </section>
                    <section><h2>@Target</h2>
                        Sur quoi porte l'annotation. ElementType[]
                        <ul>
                            <li>CONSTRUCTOR</li>
                            <li>FIELD</li>
                            <li>LOCAL_VARIABLE</li>
                            <li>METHOD</li>
                            <li>PARAMETER</li>
                            <li>PACKAGE</li>
                            <li>ANNOTATION_TYPE</li>
                            <li>TYPE : class, interface, enum ou annotation</li>
                        </ul>
                    </section>
                    <section><h2>les autres</h2>
                        <ul>
                            <li>@Inherited : l'annotation est-elle hérité par les sous-classes(défaut false)</li>
                            <li>@Documented : l'annotation apparait dans la javadoc de l'élément à laquelle elle est appliquée</li>
                        </ul>
                    </section>
                    <section><h2>Accès : runtime</h2>
                        <pre><code data-trim class="java">
...                            
Class classe = MyAnnotatedClass.class;
Author author = (Author) classe.getAnnotation(Author.class);
if (author != null) {
        System.out.println("Author:" + author.name());
}
...
                        </code></pre>
                    </section>
                    <section><h2>Accès : à la compil</h2>
                        <p>Pour cela il faut créer un Processor qui s'occupera de gérer notre annotation</p>
                        <p><code>AbstractProcessor fait une partie du boulot pour vous.</code></p>
                        <pre><code data-trim class="java">
@SupportedAnnotationTypes({"fr.craftinglabs.training.java.annotation.Print"})
public class MyProcessor extends AbstractProcessor {
    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, 
                           RoundEnvironment roundEnv) {
        //process your annotation here
        return true;
    }
}
                        </code></pre>
                        <p>On précise les annotation supportées par ce processor via une annotation</p>
                        <pre><code data-trim class="java">
@SupportedAnnotationTypes({"fr.craftinglabs.training.java.annotation.Print"})
                        </code></pre>
                    </section>  
                    <section>
                        <h2>Enregistrement</h2>
                        <p>Pour être utilisé, il faut déclarer le processor. Il faut créer une fichier </p>
                        <pre><code>
META-INF/services/javax.annotation.processing.Processor
</code></pre>
                        <p>Il doit contenir le nom des classes de processor.</p>
                    </section>
                </section>

 
                <section>
                    <section><h2>(N)IO(2)</h2></section>
                    <section><h2>IO / NIO</h2>
                        <ul>
                            <li>IO : historique, orienté stream, bloquant</li>
                            <li>NIO : orienté buffer, non bloquant</li>
                            <li>NIO2 : 1.7, dépoussiérage de l'API NIO</li>
                        </ul>
                    </section>
                    <section>
                        <h2>streams vs buffers</h2>
                        <h3>streams</h3>
                            <p>lecture d'un ou plusieurs octets depuis un stream.</p>
                            <p>pas de mise en cache.</p>
                            <p>impossible de remonter le flux.</p>
                        <h3>buffers</h3>
                            <p>lecture depuis un buffer que l'on accède comme on veux.</p>
                            <p>le buffer contient il assez d'info pour être pertinent ?</p>
                            <p>le buffer courant est écrasé à chaque lecture.</p>
                    </section>

                    <section>
                        <h2>Non blocking IO</h2>
                        <p>les opérations d'écriture/lecture sont non bloquantes. Il est donc possible de gérer des sources simultanés depuis un unique thread.</p>
                    </section>

                    <section>
                        <h2>Cas d'usage ?</h2>
                        <h3>Java IO</h3>
                        <p>Peu de connexions.</p>
                        <p>Beacoup de données.</p>
                        <h3>Java NIO</h3>
                        <p>Beaucoup de connexionx</p>
                        <p>Peu de données.</p>
                    </section>
                    <section>
                        <h2>Fichiers</h2>
                        <p>Java 7 simplifie grandement l'utilisation de NIO pour la manipulation de fichier via Files et FileSystem.</p>
                    </section>
                </section>
                <section>
                    <section><h2>Exceptions</h2></section>
                </section>
                <section>
                    <section><h1>date et timezones</h1></section>
                </section>
                    
                <section>
                    <section>
                        <h1>Java Persistence API</h1>
                    </section>
                    <section>
                        <h2>JPA</h2>
                        <p>JPA est une spécification dont l'objectif est d'uniformiser l'accès aux ORM.</p>
                        <p>Il s'agit d'un ensemble d'interface du package <code>javax.persistence</code></p>
                        <pre><code data-trim class="java">
EntityManagerFactory managerFactory = Persistence.createEntityManagerFactory("persistenceUnit");
EntityManager entityManager = managerFactory.createEntityManager();

Employee employee = new Employee("John");
entityManager.persist(employee);
                        </code></pre>
                    </section>
                    <section>
                        <h2>Intérêt</h2>
                        <ul>
                            <li>dispo dans JEE et Java SE</li>
                            <li>Mapping objet relationnel avec la BD par annotations</li>
                            <li>un langage de requêtage standardisé</li>
                        </ul>
                        <pre><code data-trim class="java">
select e from Employee e order by e.nom asc
                        </code></pre>
                    </section>
                    <section>
                        <h2>Entités</h2>
                        <pre><code data-trim class="java">
public class Employee {
@Id
@GeneratedValue
private Long id;

private String name;
// Accessors
}
                        </code></pre>
                    </section>
                    <section>
                        <h2>Entity Manager Factory</h2>
                        <p>Récupère les infos des Persistence Unit pour pouvoir créer des EntityManager.</p>
                        <p>Dans un contexte JEE, il est fourni par le serveur d'application.</p>

                        <h2>Entity Manager</h2>
                        <p>gère les échanges entre le code et la BD. Ses actions sont généralement englobé dans des transactions.</p>
                    </section>
                    <section>
                        <h2>Relations entre entités</h2>
                        <pre><code data-trim class="java">
public class Employee {
    //...
    @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JoinColumn(name = "adresse", unique = true, nullable = false)
    private Adresse adresse;
    //...
                        </code></pre> 
                        <pre><code data-trim class="java">
public class Adresse {
    // optionnel
    @OneToOne(mappedBy = "adresse")
    private Employee personne;
    //...
                        </code></pre> 
                    </section>
                            <section>
                        <h2>Relations entre entités</h2>
                        <pre><code data-trim class="java">
public class Employee {
//...
    @ManyToOne
    private Department department;
//...
                        </code></pre> 
                        <pre><code data-trim class="java">
public class Departement {

@OneToMany
private List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();
//...
                        </code></pre> 
                    </section>
                </section>

                <section>
                    <section>
                        <h1>Mémoire</h1>
                        <h1>&amp; garbage collection</h1>
                    </section>
                </section>
                <section>
                    <section>
                        <h1>Concurence</h1>    
                    </section>
                    <section>
                        <h2>C'est quoi ?</h2>
                        <p>C'est faire tourner plusieurs programme ou partie d'un programme en parallèle.</p>
                        <p>Avec le nombre de processeur/croissant dans nos machines, ne pas en tirer partie semble dommage.</p>
                    </section>

                    <section>
                        <h2>Problèmes</h2>
                        <ul>
                            <li>tous n'est pas parallélisable</li>
                            <li>il y a toujours un léger overhead à la parallélisation</li>
                            <li>visibilité des changements de données entre threads</li>
                            <li>accès concurrent</li>
                            <li>deadlock</li>
                        </ul>
                    </section>
                    <section>
                        <h2>Thread</h2>
                        <p>Il est dépendant du processus qui l'a crée.</p>
                        <p>Il peut partager des éléments avec d'autres Thread (provenant du même processus).</p>
                        <p>Chaque Thread à son propre cache mémoire pour les données partagées.</p>
                    </section>
                    <section>
                        <h2>Créer un thread</h2>
                        <pre><code data-trim class="java">
Thread t = new Thread(new MyThreadedCode());
t.start();
                        </code></pre>
                        <pre><code data-trim class="java">
public class MyThreadedCode implements Runnable {
    public void run() {
        System.out.println("Runs in a thread.");
    }
}
                        </code></pre>
                    </section>
                    <section>
                        <h2>synchronized</h2>
                        <p>Mot clé du langage, il s'applique à des blocs de code.</p>
                        <p>Un bloc synchronized ne peut être accéder que par un seul thread à la fois.</p>
                        <p>Un thread qui entre dans un bloc synchronized est sur de voir les modifications faites par celui qui vient d'en sortir.</p>
                    </section>

                    <section>
                        <h2>volatile</h2>
                        <p>Mot clé du langage, il s'applique à aux variables de classe.</p>
                        <p>Tout thread lisant une variable est sur d'en voir la dernière version.</p>
                    </section>

                    <section>
                        <h2>Les classes Atomic</h2>
                        <p>Ensemble de wrapper de type primitives Thread safe et sans lock.</p>

                        <h2>java.util.concurrent</h2>
                        <p>Propose des constructions Thread safe pour les Collections.</p>
                        <p>Note : si elles sont Thread safe, les opérations ne sont pas forcemment atomique.</p>
                    </section>

                    <section>
                        <h2>Thread et Executors</h2>
                        <p>Les Threads sont coûteux à créer et démarrer. Les Executors sont des pools de Thread.</p>
                        <pre><code data-trim class="java">

List&lt;Runnable&gt; runnables = new ArrayList&lt;Runnable&gt;();
// mettre des runables dans runnables        

ExecutorService execute = Executors.newFixedThreadPool(10);
for(Runnable r : runnables){
    service.execute(r);
}
service.shutdown();
                        </code></pre>
                    </section>

                    <section><h2>Callable et Future</h2>
                        <p>La méthode run() d'un Runnable, ne retourne rien, </p>
                        <pre><code data-trim class="java">
public interface Callable&lt;V&gt; {
    public V call() throws Exception;
}

ExecutorService execute = Executors.newSingleThreadExecutor();  
Future&lt;Integer&gt; future = execute.submit(new MonCallable());

future.get(); // bloquant, attend que le Callable est rendu son résultat.
                        </code></pre>
                    </section>
                    <section>
                        <h2>Immutabilité</h2>
                        <p>un des grosses difficultés de la concurrence est la gestion des changements d'états des données partagées. Si ces données deviennent immutable, les problèmes disparaissent, non ?</p>
                    </section>

                </section>

</div>

</div>

<script src="lib/js/head.min.js"></script>
<script src="js/reveal.js"></script>

<script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                { src: 'plugin/zoom-js/zoom.js', async: true },
                { src: 'plugin/notes/notes.js', async: true }
                ]
            });

            </script>

        </body>
        </html>
